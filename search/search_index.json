{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"Authenticating to Fabric via Microsoft365DSC November 29th, 2024 <p>Discusses how to configure your tenant to enable the use of Microsoft365DSC for the Fabric settings. The article describes a step-by-step approach to getting the authentication working against the Fabric read-only APIs.</p> Performance Considerations for Microsoft365DSC November 29th, 2024 <p>Discusses different approaches and considerations to improve the overall performance of Microsoft365DSC when taking snapshots, monitoring for configuration drifts or when deploying changes.</p> Authenticating to Microsoft Workloads using PowerShell November 28th, 2024 <p>Overview of how to connect to various Microsoft's cloud workloads using various PowerShell modules, including the MSCloudLoginAssistant module and all native workloads' modules. We also discuss how the Local Configuration Manager (LCM) authenticates and what the certificate require ments are to use Service Principal authentication.</p> Getting Started with Microsoft365DSC November 27th, 2024 <p>Introduction to configuring a brand new machine to be able to use Microsoft365DSC to take a snapshot of the configuration of an existing tenant, to monitor the tenant for configuration drifts or to automatically remediate to detected drifts.</p> Deep-Dive into the Local Configuration Manager (LCM) Error Flow June 28th, 2024 <p>Deep-dive into how the PowerShell Desired State Configuration (DSC) service, known as the Local Configuration Manager (LCM), handles errors during its execution.</p>"},{"location":"about/","title":"About Me","text":"<p>My name is Nik Charlebois and I am a Principal Program Manager at Microsoft, driving our configuration-as-code efforts for Microsoft 365. I am an ex-Microsoft MVP, a frequent conference speaker and a multi-time book author. I am the owner and creator of the Microsoft365DSC Open-Source solution, and I am based in Gatineau, Quebec (Canada).</p>"},{"location":"blog/posts/2024/authenticating-to-fabric/","title":"Authenticating to Fabric via Microsoft365DSC","text":"Authenticating to Fabric via Microsoft365DSC 2024-12-05 <p>We recently added support for Fabric settings in Microsoft365DSC via the FabricAdminTenantSettings resource. This resources uses a the Fabric API (api.fabric.microsoft.com), which was never used as part of the solution before the introducton of this resource. Important: this API is currently read-only and only allows you to read settings, for snapshot/export of monitoring pruposes. It canot be used to change settings at the moment; this is a Fabric API restriction and not a \"direct\" limitation of M365DSC. There are some things that need to be configured on your tenant before the API will allow a service principal to authenticate properly. We will cover these steps as part of this article. For the purpose of this post, we will assume that you create a brand new application registration and want to use it to authenticate, using a certificate thumbprint. For additional details on how to create such an app registration, please refer to the Getting Started with Microsoft365DSC article. In my case, I created a new app registration named FabricTest and uploaded a certficate for it.</p>"},{"location":"blog/posts/2024/authenticating-to-fabric/#securityGroup","title":"Step 1 - Create a Security Group for the Service Principal\u2693","text":"<p>The first thing we need to do is create a brand new security group in Entra ID and add our service principal as a member. This group will be used to specify what principals will have access to our Fabric APIs. In my case I created a new security group named Fabric API Access and added my FabricText service principal as a member of it.</p> <p></p>"},{"location":"blog/posts/2024/authenticating-to-fabric/#grantPermissions","title":"Step 2 - Grant Entra ID Roles to your Service Principal\u2693","text":"<p>In order to be allowed to authenticate to the Fabric API, your service principal will need to be granted an appropriate Entra ID role. We recommend granting it the Fabric Administrator role, but it will also work with the Global Reader role.</p> <p></p>"},{"location":"blog/posts/2024/authenticating-to-fabric/#allowSPN","title":"Step 3 - Allow Service Principals to Access Read-Only APIs\u2693","text":"<p>Navigate to the Fabric admin portal Tenant settings page(https://app.fabric.microsoft.com/admin-portal/tenantSettings). Once on the page, scroll down to the Admin API settings section, and expand the Service principals can access read-only admin APIs option. Make sure the toggle is set to Enabled and in the \"Specific security groups\" box, enter the name of your security group, in my case \"Fabric API Access\". Click Apply</p> <p></p>"},{"location":"blog/posts/2024/authenticating-to-fabric/#conclusion","title":"Conclusion\u2693","text":"<p>After performing the above steps, you will be able to execute a new Snapshot/Export of your tenant's configuration or perform monitoring for any configuration drift. There are currently no known plans to update the APIs to allow for the full CRUD set of operations (create &amp; update).</p>"},{"location":"blog/posts/2024/authenticating-with-powershell/","title":"Authenticating to Microsoft Workloads using PowerShell","text":"Authenticating to Microsoft Workloads using PowerShell 2024-11-28 <p>In today's world, administrators must have about a dozen different PowerShell modules under their tool belt. It seems as if every workload out there has its own PowerShell module to allow you to administer its related configuration settings; add to this the fact that every module has its own intricacy for how it let's you authenticate. For Entra Id and Intune we have the Microsoft Graph PowerShell SDK, for Teams, we have the Teams PowerShell module, for Exchange Online, there's the Exchange Online Management Shell, etc. To help simplify the overall authentication process, we put together the MSCloudLoginAssistant module, which acts as an abstraction layer sitting on top of all these modules and provies a coherent and streamlined way to authenticate to them.</p> <p>In today's article, I want to spend time walking down the authentication stack for each of the major workloads that are supported by Microsoft365DSC. For each one, we will describe how to authenticate using MSCloudLoginAssistant, but we'll also double click on how this module in turns authenticate to the lower layers by calling the workloads' specific PowerShell module directly. As part of this article, we will only focus on the Service Principal with certificate thumbprint flow. We will not cover the process of configuring a new App Registration in Entra ID as part of the article as therer are plenty of literature on the topic out there. We simply assume that you created your own app registration, and uploaded a certificate's public key to it, and that you have access to install the associated private key on your mahcine.</p> <p>For each workload we will provide the instructions to connect via the MSCloudLoginAssistant module, via its native PowerShell module and we will provide additional information about how you can leverage Microsoft365DSC to have the Local Configuration Manager (LCM) service authenticate. It is important to understand that the LCM always runs in the context of the Local System and therefore having the certificate stored in the current user's store is not sufficient in a lot of cases.</p>"},{"location":"blog/posts/2024/authenticating-with-powershell/#Graph","title":"Microsoft Graph (Entra Id and Intune)\u2693","text":"<p>Both of the Entra Id and Intune workloads in Microsoft365DSC are leveraging the various Microsoft.Graph.* PowerShell modules. In order to authenticate with the Microsoft Graph PowerShell module, you simply need to have the certificate stored in your current user's store.</p> <p></p>"},{"location":"blog/posts/2024/authenticating-with-powershell/#GraphMSCloud","title":"Via MSCloudLoginAssistant\u2693","text":"<pre><code>Connect-M365Tenant -Workload 'MicrosoftGraph' `\n                   -ApplicationId '&lt;your app id&gt;' `\n                   -TenantId '&lt;your tenant&gt;.onmicrosoft.com' `\n                   -CertificateThumbprint '&lt;your thumbprint&gt;'\n</code></pre>"},{"location":"blog/posts/2024/authenticating-with-powershell/#GraphModule","title":"Via Microsoft.Graph.Authentication\u2693","text":"<pre><code>Connect-MgGraph -ClientId '&lt;your app id&gt;' `\n                -TenantId '&lt;your tenant&gt;.onmicrosoft.com' `\n                -CertificateThumbprint '&lt;your thumbprint&gt;'\n</code></pre>"},{"location":"blog/posts/2024/authenticating-with-powershell/#GraphLCM","title":"Local Configuration Management\u2693","text":"<p>Because the LCM service runs as the local system, we need to install the certificate in the Local Computer's store as well. If you omit to install the certificate in there as well, the LCM will not be able to authenticate to the Microsoft Graph.</p> <p></p>"},{"location":"blog/posts/2024/authenticating-with-powershell/#EXO","title":"Exchange Online\u2693","text":"<p>Managing Exchange Online is done via the ExchangeOnlineManagement module. It is sufficient for you to have the certificate in the current user's store to authenticate. However, in this case, the associated application will also need to be granted the Manage as App permission, and an Entra Id role sufficient to manage Exchange. Refer to the official Exchange Online documentation for additional details.</p>"},{"location":"blog/posts/2024/authenticating-with-powershell/#EXOMSCloud","title":"Via MSCloudLoginAssistant\u2693","text":"<pre><code>Connect-M365Tenant -Workload 'ExchangeOnline' `\n                   -ApplicationId '&lt;your app id&gt;' `\n                   -TenantId '&lt;your tenant&gt;.onmicrosoft.com' `\n                   -CertificateThumbprint '&lt;your thumbprint&gt;'\n</code></pre>"},{"location":"blog/posts/2024/authenticating-with-powershell/#EXOModule","title":"Via ExchangeOnlineManagement\u2693","text":"<pre><code>Connect-ExchangeOnline -AppId '&lt;your app id&gt;' `\n                       -Organization '&lt;your tenant&gt;.onmicrosoft.com' `\n                       -CertificateThumbprint '&lt;your thumbprint&gt;'\n</code></pre>"},{"location":"blog/posts/2024/authenticating-with-powershell/#EXOLCM","title":"Local Configuration Management\u2693","text":"<p>LCM requires the certificate to be installed in the Local Machine's store in order to authenticate.</p>"},{"location":"blog/posts/2024/authenticating-with-powershell/#SC","title":"Security and Compliance (Defender &amp; Purview)\u2693","text":"<p>Managing Defender and Purview is also is done via the ExchangeOnlineManagement module. Again, it is sufficient for you to have the certificate in the current user's store to authenticate. However, in this case, the associated application will also need to be granted the Manage as App permission, and an Entra Id role sufficient to manage Defender &amp; Purview. Refer to the official Security &amp; Compliance center documentation for additional details.</p>"},{"location":"blog/posts/2024/authenticating-with-powershell/#SCMSCloud","title":"Via MSCloudLoginAssistant\u2693","text":"<pre><code>Connect-M365Tenant -Workload 'SecurityComplianceCenter' `\n                   -ApplicationId '&lt;your app id&gt;' `\n                   -TenantId '&lt;your tenant&gt;.onmicrosoft.com' `\n                   -CertificateThumbprint '&lt;your thumbprint&gt;'\n</code></pre>"},{"location":"blog/posts/2024/authenticating-with-powershell/#SCModule","title":"Via ExchangeOnlineManagement\u2693","text":"<pre><code>Connect-IPPSSession -AppId '&lt;your app id&gt;' `\n                    -Organization '&lt;your tenant&gt;.onmicrosoft.com' `\n                    -CertificateThumbprint '&lt;your thumbprint&gt;'\n</code></pre>"},{"location":"blog/posts/2024/authenticating-with-powershell/#SCLCM","title":"Local Configuration Management\u2693","text":"<p>LCM requires the certificate to be installed in the Local Machine's store in order to authenticate.</p>"},{"location":"blog/posts/2024/authenticating-with-powershell/#PnP","title":"SharePoint Online\u2693","text":"<p>In the case of Microsoft365DSC, the authentication to SharePoint Online is done via the PnP.PowerShell module. It is sufficient to have the certificate u=in the current user's store to authenticate. You will also need to make sure that the app registration is granted the Sites.FullControl.All permission for the SharePoint API (not Microsoft Graph!). </p>"},{"location":"blog/posts/2024/authenticating-with-powershell/#PnPMSCloud","title":"Via MSCloudLoginAssistant\u2693","text":"<pre><code>Connect-M365Tenant -Workload 'PnP' `\n                   -ApplicationId '&lt;your app id&gt;' `\n                   -TenantId '&lt;your tenant&gt;.onmicrosoft.com' `\n                   -CertificateThumbprint '&lt;your thumbprint&gt;'\n</code></pre>"},{"location":"blog/posts/2024/authenticating-with-powershell/#PnPModule","title":"Via PnP.PowerShell\u2693","text":"<pre><code>Connect-PnPOnline -ClientId '&lt;your app id&gt;' `\n                  -Tenant '&lt;your tenant&gt;.onmicrosoft.com' `\n                  -Thumbprint '&lt;your thumbprint&gt;' `\n                  -Url 'https://&lt;your tenant&gt;-admin.sharepoint.com'\n</code></pre>"},{"location":"blog/posts/2024/authenticating-with-powershell/#PnPLCM","title":"Local Configuration Management\u2693","text":"<p>LCM requires the certificate to be installed in the Local Machine's store in order to authenticate.</p> Power Platforms <p>Authentication to Power Platforms is handled by the Microsoft.PowerApps.Administration.PowerShell. This module currently only supports placing the certificate in the current user's store. In order to properly authenticate with the module, you will need to make sure you register your service principal as a Power App Management app. For details on how to do this, please refer to the official documentation.</p>"},{"location":"blog/posts/2024/authenticating-with-powershell/#PPMSCloud","title":"Via MSCloudLoginAssistant\u2693","text":"<pre><code>Connect-M365Tenant -Workload 'PowerPlatforms' `\n                   -ApplicationId '&lt;your app id&gt;' `\n                   -TenantId '&lt;your tenant&gt;.onmicrosoft.com' `\n                   -CertificateThumbprint '&lt;your thumbprint&gt;'\n</code></pre>"},{"location":"blog/posts/2024/authenticating-with-powershell/#PPModule","title":"Via Microsoft.PowerApps.Administration.PowerShell\u2693","text":"<pre><code>Add-PowerAppsAccount -ApplicationId '&lt;your app id&gt;' `\n                     -TenantId '&lt;your tenant&gt;.onmicrosoft.com' `\n                     -CertificateThumbprint '&lt;your thumbprint&gt;'\n</code></pre>"},{"location":"blog/posts/2024/authenticating-with-powershell/#PPLCM","title":"Local Configuration Management\u2693","text":"<p>This is where things get a little more complicated. At the time of writing this article, the Power Platforms PowerShell module only supports looking into the current user's store and not in the local system's one. Because the LCM always runs as the Local System user, this means that we need to install the certificate in the current user's store of the Local System user. Currently, the best way to achieve this is to use a tool such as PSExec to let you launch the Management Console as the Local System user and install the certificate in its store.</p> <ul> <ol>Download and install the PSTools under C:\\tools</ol> <ol>Launch a new PowerShell console as admin.</ol> <ol>Browse to C:\\tools, and execute ./Psexec.exe -i -s cmd.exe</ol> <ol>When prompted, click on Agree (only shown if it's the first time you use the tool).</ol> <ol>In the new command prompt that appeared, type in mmc.exe.</ol> <ol>In the contols that opened, press CTRL+M to open the add-in selection.</ol> <ol>Select the Certificates add-in and choose the My user account option. Click on Finish, then Ok. </ol> <ol>Expand Certificates - Curent User and select the Personal folder.</ol> <ol>In the Object Type panel, right-click and choose All Tasks &gt; Import </ol> <ol>Click Next then browse to select the private key (.pfx) for your certificate. You will need to change the file type to Personal Information Exchangefirst. </ol> <ol>Click Next then provide the password for your private key.</ol> <ol>Click Next twice and then on Finish to complete the import process.</ol> </ul> Teams\u2693 <p>Authentication to Microsof Teams is handled by the MicrosoftTeams PowerShell module. Just like all the other modules, it supports placing the certificate in the current user's store.</p>"},{"location":"blog/posts/2024/authenticating-with-powershell/#TeamsMSCloud","title":"Via MSCloudLoginAssistant\u2693","text":"<pre><code>Connect-M365Tenant -Workload 'MicrosoftTeams' `\n                   -ApplicationId '&lt;your app id&gt;' `\n                   -TenantId '&lt;your tenant&gt;.onmicrosoft.com' `\n                   -CertificateThumbprint '&lt;your thumbprint&gt;'\n</code></pre>"},{"location":"blog/posts/2024/authenticating-with-powershell/#TeamsModule","title":"Via MicrosoftTeams\u2693","text":"<pre><code>Connect-MicrosoftTeams -ApplicationId '&lt;your app id&gt;' `\n                       -TenantId '&lt;your tenant&gt;.onmicrosoft.com' `\n                       -CertificateThumbprint '&lt;your thumbprint&gt;'\n</code></pre>"},{"location":"blog/posts/2024/authenticating-with-powershell/#TeamsLCM","title":"Local Configuration Management\u2693","text":"<p>LCM requires the certificate to be installed in the Local Machine's store in order to authenticate.</p>"},{"location":"blog/posts/2024/dsc-error-flow/","title":"Deep-Dive into the Local Configuration Manager (LCM) Error Flow","text":"Deep-Dive into the Local Configuration Manager (LCM) Error Flow 2024-06-28 <p>How to handle the error flow when an error is thrown during a deployment of a configuration baseline is an ongoing debate within the config-as-code community. Should you stop the entire deployment flow the moment an error is encountered, or should you allow the process to continue past the error to attempt and deploy other components? This article aims to shed light on how the current Local Configuration Manager (LCM) service handles the error flow in configuration deployment and describes what options are available users to have some control over it.</p> <p>To better illustrate the options that are available to the users, I\u2019ve created a bogus Desired State Configuration (DSC) module named BlogDSC which contains 2 resources: 1 that will always succeed its execution without errors (WorkingResource), and 1 that will always fail its execution and throw an error (FailingResource). The FailingResource will accept a parameter that will specify in what method the error should be thrown (Get/Set/Test). Both resources will return $false from their Test-TargetResource method in order to allow the LCM flow to call into the Set-TargetResource. Upon entering a method, the module's logic will log an entry in Event Viewer. We will use these event logs to confirm the execution flow of our resources and their methods.</p> <p>Controlling the error flow in DSC is limited to using the -ErrorAction parameter with Continue or Stop when calling into the Start-DSCConfiguration cmdlet, or by specifying dependencies between resource instances in your configuration using the DependsOn parameter. One thing that is very important to understand is that the -ErrorAction parameter only takes effect when the Start-DSCConfiguration cmdlet is ran synchronously with the -Wait switch, otherwise the execution will default to -ErrorAction 'Continue'. For each example below, I will highlight the resources\u2019 methods that were called by the LCM service.</p>"},{"location":"blog/posts/2024/dsc-error-flow/#example1a","title":"Example 1a - No Dependencies \u2013 Fail in Test \u2013 ErrorAction Continue\u2693","text":"<p>In this example, we've defined a configuration that defines 3 resource instances, and no inter-dependencies between any of them.</p> <p></p> <pre><code>    WorkingResource 'Work1'\n    {\n        Id = 'WorkId1'\n        Ensure = 'Present'\n    }\n\n    FailingResource 'FailTest1'\n    {\n        Id           = 'FailId1'\n        MethodToFail = \"Test\"\n        Ensure       = 'Present'\n    }\n\n    WorkingResource 'Work2'\n    {\n        Id = 'WorkId2'\n        Ensure = 'Present'\n    }\n</code></pre> <p></p> <p>Based on the above screenshot, we would assume that the overall execution flow is the following, in order and where items in green get executed and items in red never get executed:</p> <ul> <li>Work1</li> <ul> <li>Test</li> <li>Set</li> </ul> <li>Fail1</li> <ul> <li>Test (Error thrown)</li> <li>Set</li> </ul> <li>Work2</li> <ul> <li>Test</li> <li>Set</li> </ul> </ul> <p>Taking a look at Event Viewer, we can confirm the above execution flow:</p> <p></p>"},{"location":"blog/posts/2024/dsc-error-flow/#example1b","title":"Example 1b - No Dependencies \u2013 Fail in Test \u2013 ErrorAction Stop\u2693","text":"<p>In this example, we\u2019ve are using the same configuration as above, which defines 3 resource instances, and no inter-dependencies between any of them. This time we are specifying the ErrorAction to be stop.</p> <p></p> <pre><code>    WorkingResource 'Work1'\n    {\n        Id     = 'WorkId1'\n        Ensure = 'Present'\n    }\n\n    FailingResource 'FailTest1'\n    {\n        Id           = 'FailId1'\n        MethodToFail = \"Test\"\n        Ensure       = 'Present'\n    }\n\n    WorkingResource 'Work2'\n    {\n        Id     = 'WorkId2'\n        Ensure = 'Present'\n    }\n</code></pre> <p></p> <p>Based on the above screenshot, we would assume that the overall execution flow is the following, in order and where items in green get executed and items in red never get executed:</p> <ul> <li>Work1</li> <ul> <li>Test</li> <li>Set</li> </ul> <li>Fail1</li> <ul> <li>Test (Error thrown)</li> <li>Set</li> </ul> <li>Work2</li> <ul> <li>Test</li> <li>Set</li> </ul> </ul> <p>Taking a look at Event Viewer, we are observing an extra entry being made on the Test method for the Work2 resource instance:</p> <p></p> <p>This is due to the fact that even when we specify that we want the synchronous error flow to stop upon encountering the first error, the LCM engine needs to evaluate the remaining instances for drifts. The LCM will not however call into the Set-TargetResource of these resources that are defined past the first failure.</p>"},{"location":"blog/posts/2024/dsc-error-flow/#example2a","title":"Example 2a - No Dependencies \u2013 Fail in Set \u2013 ErrorAction Continue\u2693","text":"<p>In this example, we\u2019ve are using the same configuration as above, which defines 3 resource instances, and no inter-dependencies between any of them. We are specifying the ErrorAction to be continue.</p> <p></p> <pre><code>    WorkingResource 'Work1'\n    {\n        Id     = 'WorkId1'\n        Ensure = 'Present'\n    }\n\n    FailingResource 'FailTest1'\n    {\n        Id           = 'FailId1'\n        MethodToFail = \"Set\"\n        Ensure       = 'Present'\n    }\n\n    WorkingResource 'Work2'\n    {\n        Id     = 'WorkId2'\n        Ensure = 'Present'\n    }\n</code></pre> <p></p> <p>Based on the above screenshot, we assume that the overall execution flow is the following, in order and where items in green get executed and items in red never get executed:</p> <ul> <li>Work1</li> <ul> <li>Test</li> <li>Set</li> </ul> <li>Fail1</li> <ul> <li>Test</li> <li>Set(Error thrown)</li> </ul> <li>Work2</li> <ul> <li>Test</li> <li>Set</li> </ul> </ul> <p>Taking a look at Event Viewer, we can confirm the above execution flow: </p>"},{"location":"blog/posts/2024/dsc-error-flow/#example2b","title":"Example 2b - No Dependencies \u2013 Fail in Set \u2013 ErrorAction Stop\u2693","text":"<p>In this example, we\u2019ve are using the same configuration as above, which defines 3 resource instances, and no inter-dependencies between any of them. This time we are specifying the ErrorAction to be stop.</p> <p></p> <pre><code>    WorkingResource 'Work1'\n    {\n        Id     = 'WorkId1'\n        Ensure = 'Present'\n    }\n\n    FailingResource 'FailTest1'\n    {\n        Id           = 'FailId1'\n        MethodToFail = \"Set\"\n        Ensure       = 'Present'\n    }\n\n    WorkingResource 'Work2'\n    {\n        Id     = 'WorkId2'\n        Ensure = 'Present'\n    }\n</code></pre> <p></p> <p>Based on the above screenshot, we would assume that the overall execution flow is the following, in order and where items in green get executed and items in red never get executed:</p> <ul> <li>Work1</li> <ul> <li>Test</li> <li>Set</li> </ul> <li>Fail1</li> <ul> <li>Test</li> <li>Set (Error thrown)</li> </ul> <li>Work2</li> <ul> <li>Test</li> <li>Set</li> </ul> </ul> <p>Taking a look at Event Viewer, we are observing an extra entry being made on the Test method for the Work2 resource instance:</p> <p></p> <p>This is due to the fact that even when we specify that we want the synchronous error flow to stop upon encountering the first error, the LCM engine needs to evaluate the remaining instances for drifts. The LCM will not however call into the Set-TargetResource of these resources that are defined past the first failure.</p>"},{"location":"blog/posts/2024/dsc-error-flow/#example3a","title":"Example 3a - Dependencies Specified \u2013 Fail in Test \u2013 ErrorAction Continue\u2693","text":"<p>In this example, we\u2019ve defined a configuration that defines 4 resource instances, where the 3rd instance has a dependency on the second one, which will fail in the Test method</p> <p></p> <pre><code>    WorkingResource 'Work1'\n    {\n        Id     = 'WorkId1'\n        Ensure = 'Present'\n    }\n\n    FailingResource 'FailTest1'\n    {\n        Id           = 'FailId1'\n        MethodToFail = \"Test\"\n        Ensure       = 'Present'\n    }\n\n    WorkingResource 'Work2'\n    {\n        Id        = 'WorkId2'\n        Ensure    = 'Present'\n        DependsOn = \"[FailingResource]FailTest1\"\n    }\n\n    WorkingResource 'Work3'\n    {\n        Id     = 'WorkId3'\n        Ensure = 'Present'\n    }\n</code></pre> <p></p> <p>We can see that there is no output in the console for resource Work2. This is due to the fact that this resource depends on the FailTest1 resource which failed. Dependencies are not being executed, even when the ErrorAction parameter is set to continue. However, other resource instances defined on the main sequential path are executed as expected, in this occurence resource Work3.</p> <p>Based on the above screenshot, we would assume that the overall execution flow is the following, in order and where items in green get executed and items in red never get executed:</p> <ul> <li>Work1</li> <ul> <li>Test</li> <li>Set</li> </ul> <li>Fail1</li> <ul> <li>Test(Error thrown)</li> <li>Set</li> </ul> <li>Work2</li> <ul> <li>Test</li> <li>Set</li> </ul> <li>Work3</li> <ul> <li>Test</li> <li>Set</li> </ul> </ul> <p>Taking a look at Event Viewer, we can confirm the above execution flow: </p>"},{"location":"blog/posts/2024/dsc-error-flow/#example3b","title":"Example 3b - Dependencies Specified \u2013 Fail in Test \u2013 ErrorAction Stop\u2693","text":"<p>In this example, we\u2019ve defined a configuration that defines 4 resource instances, where the 3rd instance has a dependency on the second one, which will fail in the Test method. We are also specifying -ErrorAction Stop.</p> <p></p> <pre><code>    WorkingResource 'Work1'\n    {\n        Id     = 'WorkId1'\n        Ensure = 'Present'\n    }\n\n    FailingResource 'FailTest1'\n    {\n        Id           = 'FailId1'\n        MethodToFail = \"Test\"\n        Ensure       = 'Present'\n    }\n\n    WorkingResource 'Work2'\n    {\n        Id        = 'WorkId2'\n        Ensure    = 'Present'\n        DependsOn = \"[FailingResource]FailTest1\"\n    }\n\n    WorkingResource 'Work3'\n    {\n        Id     = 'WorkId3'\n        Ensure = 'Present'\n    }\n</code></pre> <p></p> <p>Based on the above screenshot, we would assume that the overall execution flow is the following, in order and where items in green get executed and items in red never get executed:</p> <ul> <li>Work1</li> <ul> <li>Test</li> <li>Set</li> </ul> <li>Fail1</li> <ul> <li>Test (Error thrown)</li> <li>Set</li> </ul> <li>Work2</li> <ul> <li>Test</li> <li>Set</li> </ul> </ul> <p>Taking a look at Event Viewer, we again observe that the other items in the main sequential path have their Test method being executed. Items that are not in the main sequential path don't if their parent dependency failed.</p> <p></p>"},{"location":"blog/posts/2024/dsc-error-flow/#example4a","title":"Example 4a - Dependencies Specified \u2013 Fail in Set \u2013 ErrorAction Continue\u2693","text":"<p>In this example, we\u2019ve defined a configuration that defines 4 resource instances, where the 3rd instance has a dependency on the second one, which will fail in the Set method</p> <p></p> <pre><code>    WorkingResource 'Work1'\n    {\n        Id     = 'WorkId1'\n        Ensure = 'Present'\n    }\n\n    FailingResource 'FailTest1'\n    {\n        Id           = 'FailId1'\n        MethodToFail = \"Set\"\n        Ensure       = 'Present'\n    }\n\n    WorkingResource 'Work2'\n    {\n        Id        = 'WorkId2'\n        Ensure    = 'Present'\n        DependsOn = \"[FailingResource]FailTest1\"\n    }\n\n    WorkingResource 'Work3'\n    {\n        Id     = 'WorkId3'\n        Ensure = 'Present'\n    }\n</code></pre> <p></p> <p>We can see that there is no output in the console for resource Work2. This is due to the fact that this resource depends on the FailTest1 resource which failed. Dependencies are not being executed, even when the ErrorAction parameter is set to continue. However, other resource instances defined on the main sequential path are executed as expected, in this occurence resource Work3.</p> <p>Based on the above screenshot, we would assume that the overall execution flow is the following, in order and where items in green get executed and items in red never get executed:</p> <ul> <li>Work1</li> <ul> <li>Test</li> <li>Set</li> </ul> <li>Fail1</li> <ul> <li>Test</li> <li>Set (Error thrown)</li> </ul> <li>Work2</li> <ul> <li>Test</li> <li>Set</li> </ul> <li>Work3</li> <ul> <li>Test</li> <li>Set</li> </ul> </ul> <p>Taking a look at Event Viewer, we can confirm the above execution flow: </p>"},{"location":"blog/posts/2024/dsc-error-flow/#example4b","title":"Example 4b - Dependencies Specified \u2013 Fail in Set \u2013 ErrorAction Stop\u2693","text":"<p>In this example, we\u2019ve defined a configuration that defines 4 resource instances, where the 3rd instance has a dependency on the second one, which will fail in the Set method. We are also specifying -ErrorAction Stop.</p> <p></p> <pre><code>    WorkingResource 'Work1'\n    {\n        Id     = 'WorkId1'\n        Ensure = 'Present'\n    }\n\n    FailingResource 'FailTest1'\n    {\n        Id           = 'FailId1'\n        MethodToFail = \"Set\"\n        Ensure       = 'Present'\n    }\n\n    WorkingResource 'Work2'\n    {\n        Id        = 'WorkId2'\n        Ensure    = 'Present'\n        DependsOn = \"[FailingResource]FailTest1\"\n    }\n\n    WorkingResource 'Work3'\n    {\n        Id     = 'WorkId3'\n        Ensure = 'Present'\n    }\n</code></pre> <p></p> <p>Based on the above screenshot, we would assume that the overall execution flow is the following, in order and where items in green get executed and items in red never get executed:</p> <ul> <li>Work1</li> <ul> <li>Test</li> <li>Set</li> </ul> <li>Fail1</li> <ul> <li>Test</li> <li>Set (Error thrown)</li> </ul> <li>Work2</li> <ul> <li>Test</li> <li>Set</li> </ul> <li>Work3</li> <ul> <li>Test</li> <li>Set</li> </ul> </ul> <p>Taking a look at Event Viewer, we again observe that the other items in the main sequential path have their Test method being executed. Items that are not in the main sequential path don't if their parent dependency failed.</p> <p></p>"},{"location":"blog/posts/2024/dsc-error-flow/#example5a","title":"Example 5a - Failure in Dependency Chain \u2013 ErrorAction Continue\u2693","text":"<p>In this example, we\u2019ve defined a configuration that defines 5 resource instances. We are defining a dependency chain, where one of the links throws a failure.</p> <p></p> <pre><code>    WorkingResource 'Work1'\n    {\n        Id     = 'WorkId1'\n        Ensure = 'Present'\n    }\n\n    WorkingResource 'Work2'\n    {\n        Id           = 'WorkId2'\n        Ensure       = 'Present'\n    }\n\n    FailingResource 'Fail1'\n    {\n        Id           = 'Fail1'\n        MethodToFail = \"Test\"\n        Ensure       = 'Present'\n        DependsOn    = '[WorkingResource]Work2'\n    }\n\n    WorkingResource 'Work3'\n    {\n        Id        = 'WorkId3'\n        Ensure    = 'Present'\n        DependsOn = \"[FailingResource]Fail1\"\n    }\n\n    WorkingResource 'Work4'\n    {\n        Id        = 'WorkId4'\n        Ensure    = 'Present'\n    }\n</code></pre> <p></p> <p>We can see that there is no output in the console for resource Work3. This is due to the fact that this resource depends on the FailTest1 resource which failed. Dependencies are not being executed, even when the ErrorAction parameter is set to continue. However, other resource instances defined on the main sequential path are executed as expected, in this occurence resource Work4.</p> <p>Based on the above screenshot, we would assume that the overall execution flow is the following, in order and where items in green get executed and items in red never get executed:</p> <ul> <li>Work1</li> <ul> <li>Test</li> <li>Set</li> </ul> <li>Work2</li> <ul> <li>Test</li> <li>Set</li> </ul> <li>Fail1</li> <ul> <li>Test (Error thrown)</li> <li>Set</li> </ul> <li>Work3</li> <ul> <li>Test</li> <li>Set</li> </ul> <li>Work4</li> <ul> <li>Test</li> <li>Set</li> </ul> </ul> <p>Taking a look at Event Viewer, we can confirm the above execution flow: </p>"},{"location":"blog/posts/2024/dsc-error-flow/#example5b","title":"Example 5b - Failure in Dependency Chain \u2013 ErrorAction Stop\u2693","text":"<p>In this example, we\u2019ve defined a configuration that defines 5 resource instances. We are defining a dependency chain, where one of the links throws a failure.</p> <p></p> <pre><code>    WorkingResource 'Work1'\n    {\n        Id     = 'WorkId1'\n        Ensure = 'Present'\n    }\n\n    WorkingResource 'Work2'\n    {\n        Id           = 'WorkId2'\n        Ensure       = 'Present'\n    }\n\n    FailingResource 'Fail1'\n    {\n        Id           = 'Fail1'\n        MethodToFail = \"Test\"\n        Ensure       = 'Present'\n    }\n\n    WorkingResource 'Work3'\n    {\n        Id        = 'WorkId3'\n        Ensure    = 'Present'\n        DependsOn = \"[FailingResource]Fail1\"\n    }\n\n    WorkingResource 'Work4'\n    {\n        Id        = 'WorkId4'\n        Ensure    = 'Present'\n    }\n</code></pre> <p></p> <p>Based on the above screenshot, we would assume that the overall execution flow is the following, in order and where items in green get executed and items in red never get executed:</p> <ul> <li>Work1</li> <ul> <li>Test</li> <li>Set</li> </ul> <li>Work2</li> <ul> <li>Test</li> <li>Set</li> </ul> <li>Fail1</li> <ul> <li>Test (Error thrown)</li> <li>Set</li> </ul> <li>Work3</li> <ul> <li>Test</li> <li>Set</li> </ul> <li>Work4</li> <ul> <li>Test</li> <li>Set</li> </ul> </ul> <p>Taking a look at Event Viewer, we again observe that the other items in the main sequential path have their Test method being executed. Items that are not in the main sequential path don't if their parent dependency failed.</p> <p></p>"},{"location":"blog/posts/2024/dsc-error-flow/#example6a","title":"Example 6a - Advanced \u2013 ErrorAction Continue\u2693","text":"<p>To summarize what we've covered so far, let's take a look at an advanced scenario:</p> <p></p> <pre><code>    WorkingResource 'Work1'\n        {\n            Id     = 'WorkId1'\n            Ensure = 'Present'\n        }\n\n        WorkingResource 'Work2'\n        {\n            Id        = 'WorkId2'\n            Ensure    = 'Present'\n        }\n\n        WorkingResource 'Work3'\n        {\n            Id        = 'WorkId3'\n            Ensure    = 'Present'\n            DependsOn = \"[WorkingResource]Work2\"\n        }\n\n        WorkingResource 'Work4'\n        {\n            Id        = 'WorkId4'\n            Ensure    = 'Present'\n            DependsOn = \"[WorkingResource]Work3\"\n        }\n\n        FailingResource 'Fail1'\n        {\n            Id           = 'FailId1'\n            MethodToFail = \"Test\"\n            Ensure       = 'Present'\n            DependsOn    = \"[WorkingResource]Work2\"\n        }\n\n        WorkingResource 'Work5'\n        {\n            Id        = 'WorkId5'\n            Ensure    = 'Present'\n            DependsOn = \"[FailingResource]Fail1\"\n        }\n</code></pre> <p></p> <p>Based on the above screenshot, we would assume that the overall execution flow is the following, in order and where items in green get executed and items in red never get executed:</p> <ul> <li>Work1</li> <ul> <li>Test</li> <li>Set</li> </ul> <li>Work2</li> <ul> <li>Test</li> <li>Set</li> </ul> <li>Work3</li> <ul> <li>Test</li> <li>Set</li> </ul> <li>Fail1</li> <ul> <li>Test (Error thrown)</li> <li>Set</li> </ul> <li>Work4</li> <ul> <li>Test</li> <li>Set</li> </ul> <li>Work5</li> <ul> <li>Test</li> <li>Set</li> </ul> </ul> <p>Taking a look at Event Viewer, we can confirm the above execution flow: </p>"},{"location":"blog/posts/2024/dsc-error-flow/#example6b","title":"Example 6b - Advanced \u2013 ErrorAction Stop\u2693","text":"<p>To summarize what we've covered so far, let's take a look at an advanced scenario:</p> <p></p> <pre><code>    WorkingResource 'Work1'\n        {\n            Id     = 'WorkId1'\n            Ensure = 'Present'\n        }\n\n        WorkingResource 'Work2'\n        {\n            Id        = 'WorkId2'\n            Ensure    = 'Present'\n        }\n\n        WorkingResource 'Work3'\n        {\n            Id        = 'WorkId3'\n            Ensure    = 'Present'\n            DependsOn = \"[WorkingResource]Work2\"\n        }\n\n        WorkingResource 'Work4'\n        {\n            Id        = 'WorkId4'\n            Ensure    = 'Present'\n            DependsOn = \"[WorkingResource]Work3\"\n        }\n\n        FailingResource 'Fail1'\n        {\n            Id           = 'FailId1'\n            MethodToFail = \"Test\"\n            Ensure       = 'Present'\n            DependsOn    = \"[WorkingResource]Work2\"\n        }\n\n        WorkingResource 'Work5'\n        {\n            Id        = 'WorkId5'\n            Ensure    = 'Present'\n            DependsOn = \"[FailingResource]Fail1\"\n        }\n</code></pre> <p></p> <p>Based on the above screenshot, we would assume that the overall execution flow is the following, in order and where items in green get executed and items in red never get executed. Note: in this scenario, the outcome is the same as when we used the -ErrorAction parameter with value 'Continue'.</p> <ul> <li>Work1</li> <ul> <li>Test</li> <li>Set</li> </ul> <li>Work2</li> <ul> <li>Test</li> <li>Set</li> </ul> <li>Work3</li> <ul> <li>Test</li> <li>Set</li> </ul> <li>Fail1</li> <ul> <li>Test (Error thrown)</li> <li>Set</li> </ul> <li>Work4</li> <ul> <li>Test</li> <li>Set</li> </ul> <li>Work5</li> <ul> <li>Test</li> <li>Set</li> </ul> </ul> <p>Taking a look at Event Viewer, we again observe that the other items in the main sequential path have their Test method being executed. Items that are not in the main sequential path don't if their parent dependency failed.</p> <p></p>"},{"location":"blog/posts/2024/getting-started-m365dsc/","title":"Getting Started with Microsoft365DSC","text":"Getting Started with Microsoft365DSC 2024-11-27 <p>In this article, we will guide you through all the steps involved in getting up and running with Microsoft365DSC. For the purpose of this article, I created a brand new Windows Server 2025 virtual machine and this is the environment I will be using throughout this blog post. Please note that we will also be using Windows PowerShell 5.1 for all steps described below. It is important to note that at the time of writing this article, the latest Microsoft365DSC version was 1.24.1127.1. Also, while it is possible for you to export the configuration of an existing tenant using administrator credentials, for the purpose of this article, we will use the recommended authentication approach which is to use a Service Principal to authenticate with a certificate to secure the connection.</p>"},{"location":"blog/posts/2024/getting-started-m365dsc/#step1","title":"Step 1 - Install the Core Microsoft365DSC Module\u2693","text":"<p>Open a new Windows PowerShell (version 5.1) windows as an administrator.</p> <p></p> <p>Run the following line of PowerShell code. This will pull the Microsoft365DSC module from the PowerShell Gallery and install it on the machine under the path c:\\Program Files\\WindowsPowerShell\\Modules\\Microsoft365DSC\\ <pre><code>Install-Module Microsoft365DSC -Force\n</code></pre> <p>If prompted to install the latest version of the nuget provider, type in Y.</p> <p></p>"},{"location":"blog/posts/2024/getting-started-m365dsc/#step2","title":"Step 2- Update Dependencies\u2693","text":"<p>Microsoft365DSC depends on about a dozen different other modules (e.g., the Exchange Online Management Shell, the Teams PowerShell Moduel, the Graph PowerShell SDK, etc.). The previous step only installed the core Microsoft365DSC PowerShell module, but di not install any of its dependencies, which are required for the module to run properly. The next step of the installation consists of downloading and installing all of these dependencies. If you are curious to understand what all these dependencies are, you can refer to the Microsoft365DSC Dependency Manifest file. In order to download and install all these dependencies, simply run the following PowerShell cmdlet.</p> <pre><code>Update-M365DSCModule\n</code></pre> <p></p> <p>Note: Running this command will automatically download all the dependencies from the PowerShell Gallery and install them under C:\\Program Files\\WindowsPowerShell\\Modules\\.</p>"},{"location":"blog/posts/2024/getting-started-m365dsc/#step3","title":"Step 3 - Configure the Agent &amp; Generate the Certificate\u2693","text":"<p>The next thing we need to do is generate a certificate which will serve a dual purpose. On one hand, it will secure our authentication process with our service principal, and on the other hand it will encrypt our compiled DSC configuration file to ensure we don't expose any plaintext passwords or secrets. As part of the Microsoft365DSc module, we provide a single cmdlets which allows you to generate the certificate and automatically configure the Local Configuration Manager (LCM) service so that it can use it to decrypt our configuration files. To initiate the process, run the following PowerShell command:</p> <pre><code>Set-M365DSCAgentCertificateConfiguration -KeepCertificate -GeneratePFX -Password '&lt;choose a password&gt;'\n</code></pre> <p></p> <p>As stated by the output, this will go and generate both a public .cer and a private .pfx certificate file under the listed path. I strongly recommend you copy those somewhere safe since files in the temps folder will eventually get purged. In my case, I will be copying these under C:\\DSC.</p> <p></p> <p>As stated previously, on top of generating the certificate files, the cmdlet also configured your LCM service to use the generated certificate to decrypt configurations. To confirm that the LCM service is properly configured to use the new certificate, you can run the following PowerShell cmdlet and ensure that the CertificateID property reflects the thumbprint of the new certificate.</p> <pre><code>Get-DSCLocalConfigurationManager\n</code></pre> <p></p>"},{"location":"blog/posts/2024/getting-started-m365dsc/#step4","title":"Step 4 - Install the Certificate on the Machine\u2693","text":"<p>Once you've confirmed that the LCM is properly configured, the next step is to install the certificate's private key on the machine where you will be running Microsoft365DSC from. To install the certificate in this location, simply double click on the .pfx file and select the Current User as the store location.</p> <p></p> <p>Click the Next button twice, and when prompted to provide the password, type in the password you chosse at step 3 above, when you generated the certificate and its private key. Once the password is entered, leave all the other settings as default and click Next again.</p> <p></p> <p>Click Next on the following screen, leaving the default value to \"Automatically select the certificate store based on the type of certificate\". Then click Finish on the last screen.</p> <p>Note:When running DSC via the LCM (e.g., with Start-DSCConfiguration or Test-DSCConfiguration) you will also need to put the certificate in the Local Computer store.</p> <p></p>"},{"location":"blog/posts/2024/getting-started-m365dsc/#step5","title":"Step 5 - Create a Service Principal\u2693","text":"<p>As mentionned at the beginning of this article, we will be authenticating to our tenants using a service principal (SPN). In order to create such an SPN, start by navigating to: Azure App Registration Portal for your tenant. In the to bar, click on New registration.</p> <p></p> <p>Provide a name for your new app, leave all the default settings selected and click on Register at the bottom.</p> <p></p> <p>On the next screen, take note of the Application (client) ID value for your newly created app. This value is refered to as the ApplicationId property in the context of Microsoft365DSC. In the left navigation, click on the Certificates &amp; secrets link. From there, click on the Certificates (0) header, and then on the Upload certificate button. When prompted, select the public certificate .cer file that was generated at Step 3 above and upload it.</p> <p></p> <p>Once the certificate has been successfully uploaded, make sure to copy the Thumbprint value (not the Certificate ID). You will need to keep this value handy as this is refered to as the CertificateThumbprint property in the context of Microsoft365DSC. The last piece of information you need to be able to authenticate t your tenant via your Service Principal, is the Tenant Id. Now, don't let the name of this property fool you, what we actually need is the domain name of the tenant in the form of *.onmicrosoft.com and not the actual tenant's GUID. To find this informatiom, you can navigate to the root of you Entra ID portal, and take a not of the Primary domain value.</p> <p></p> <p>In the context of Microsoft365DSC, this value is known as the TenantId property.</p>"},{"location":"blog/posts/2024/getting-started-m365dsc/#step6","title":"Step 6 - Grant Permission to the Service Principal\u2693","text":"<p>By default, our service principal only has access to read the current user's profile. In order for us to be able to either take a snapshot, monitor or make changes to a configuration setting via DSC, we need to grant it the appropriate API permissions. For the purpose of this article, we will focus on the Entra ID Conditional Access Policies. To learn more about the required permissions for all other DSc resources, please refer to the official website at https://Microsoft365DSC.com. We can determine what the required permissions for any given DSC resource are by looking at its associated settings.json file. For example, in the case of the AADConditionalAccessPolicy resource, which is the resource associated with Entra ID Conditional Access Policies, the setting file can be found at https://github.com/microsoft/Microsoft365DSC/blob/Dev/Modules/Microsoft365DSC/DSCResources/MSFT_AADConditionalAccessPolicy/settings.json.</p> <p>In the case of DSC, we are only interested in the application permissions and can disregard the delegated permissions since the solution only deals with app-only permissions in the context of a Service Principal. By looking at the file, we see that we are listing both the permissions for the read and update scenarios.</p> <p></p> <p>The read scenario represents the case where all you are trying to achieve with your Service Principal is either to export (take a snapshot) of instance of the resource, in occurence a snapshot of all conditional access policies in the tenant, or where you are trying to monitor them for configuration drifts. The update scenario on the other hand is for when you are trying to set the configuration settings, either via an initial deployment of a config, via approved configuration changes or when automatically trying to remediate to detected configuration drifts. It is important to note that the update permissions are a superset of the read permissions and that be granting those to you Service Principal, you are also explicitely allowing it to read the settings. In our case, we will go ahead and grant our app registration all the required permissions for the update scenario. Note:: In addition to these permissions, each Service Principal trying to authenticate via Microsoft365DSC will need to Directory.Read.All permissions in order to ensure the provided tenant Id is the primary domain.</p> <p></p> <p>By default, all assigned API permissions are not granted consent at the organization level and therefore cannot be used by your service principal. You will need to grant consent to these permissions on behalf of your organization by clicking on the Grant admin consent for Contoso button and accepting the prompt.</p> <p></p> <p>Once the consent has been successfully granted, you should see the warning icons updated to reflect green checkmarks instead.</p> <p></p>"},{"location":"blog/posts/2024/getting-started-m365dsc/#step7","title":"Step 7 - Take a Snapshot\u2693","text":"<p>We are finally ready to start and take a snapshot of our tenant. Make sure you open a new PowerShell consol running as admin and type in the following command, making sure to replace the ApplicationId, TenantId and CertificateThumbprint parameters by the values you noted in Step 5 above.</p> <pre><code>Export-M365DSCConfiguration -ApplicationId '&lt;ApplicationId&gt;' -TenantId '&lt;TenantId&gt;' -CertificateThumbprint '&lt;CertificateThumbprint&gt;' -Components @('AADConditionalAccessPolicy')\n</code></pre> <p>Once the execution completes, make sure you provide a path to store the resulting files. If the provided path doesn't exist, Microsoft365DSC will create it by default and store the exported files at this location.</p> <p></p> <p>The export process will generate 3 files. The .ps1 file is known as the configuration file contains the exported configuration content (info about the conditional access policies on your tenant). The .psd1 file is known as the Configuration Data file and contains specific information about the tenant where the configuration was exported from (e.g., the application id used, the tenant id and the certificat thumbprint). The 3rd file is a copy of the public certificazte (.cer) file that is associated with your Local Configuration Manager service.</p>"},{"location":"blog/posts/2024/getting-started-m365dsc/#step8","title":"Step 8 - Deploy Configuration Changes\u2693","text":"<p>The next thing we will do is deploy a new Conditional Access Policy using DSC. To do so, I will go ahead and modify the M365TenantConfig.ps1 file I extracted at Step 7 above and replace its entire content by the following lines:</p> <pre><code>param (\n)\n\nConfiguration M365TenantConfig\n{\n    param (\n    )\n\n    $OrganizationName = $ConfigurationData.NonNodeData.OrganizationName\n\n    Import-DscResource -ModuleName 'Microsoft365DSC' -ModuleVersion '1.24.1127.1'\n\n    Node localhost\n    {\n        AADConditionalAccessPolicy \"AADConditionalAccessPolicy-BlogPost\"\n        {\n            ApplicationEnforcedRestrictionsIsEnabled = $False;\n            ApplicationId                            = $ConfigurationData.NonNodeData.ApplicationId;\n            AuthenticationContexts                   = @();\n            BuiltInControls                          = @(\"mfa\");\n            CertificateThumbprint                    = $ConfigurationData.NonNodeData.CertificateThumbprint;\n            ClientAppTypes                           = @(\"all\");\n            CloudAppSecurityIsEnabled                = $False;\n            CloudAppSecurityType                     = \"\";\n            CustomAuthenticationFactors              = @();\n            DeviceFilterRule                         = \"\";\n            DisplayName                              = \"Blog Demo CAP\";\n            Ensure                                   = \"Present\";\n            ExcludeApplications                      = @();\n            ExcludeExternalTenantsMembers            = @();\n            ExcludeExternalTenantsMembershipKind     = \"\";\n            ExcludeGroups                            = @();\n            ExcludeLocations                         = @();\n            ExcludePlatforms                         = @();\n            ExcludeRoles                             = @(\"Directory Synchronization Accounts\");\n            ExcludeUsers                             = @(\"admin@$($OrganizationName)\");\n            GrantControlOperator                     = \"OR\";\n            IncludeApplications                      = @(\"All\");\n            IncludeExternalTenantsMembers            = @();\n            IncludeExternalTenantsMembershipKind     = \"\";\n            IncludeGroups                            = @();\n            IncludeLocations                         = @();\n            IncludePlatforms                         = @();\n            IncludeRoles                             = @();\n            IncludeUserActions                       = @();\n            IncludeUsers                             = @(\"All\");\n            PersistentBrowserIsEnabled               = $False;\n            PersistentBrowserMode                    = \"\";\n            SignInFrequencyIsEnabled                 = $False;\n            SignInFrequencyType                      = \"\";\n            SignInRiskLevels                         = @();\n            State                                    = \"enabledForReportingButNotEnforced\";\n            TenantId                                 = $OrganizationName;\n            TransferMethods                          = \"\";\n            UserRiskLevels                           = @();\n        }\n    }\n}\n\nM365TenantConfig -ConfigurationData .\\ConfigurationData.psd1\n</code></pre> <p>Using your PowerShell console, browse to the location where the .ps1 file is and execute it as if it was any other PowerShell script out there. This is what we call compiling a DSC configuration file. If successful, you should see an output similar to the screen below, which states that the file was successfully compiled into a  file. <p></p> <p>All that is left is for us to start the configuration deployment by running the following PowerShell command:</p> <pre><code>Start-DSCConfiguration M365TenantConfig -Wait -Verbose -Force\n</code></pre> <p></p> <p>Once the execution successfully completes (no error thrown), you may want to navigate to the Azure portal to confirm that the policy was created as expected.</p> <p></p>"},{"location":"blog/posts/2024/getting-started-m365dsc/#step9","title":"Step 9 - Monitoring for Configuration Drifts\u2693","text":"<p>By default, once you've deployed a configuration file as shown in Step 8 above, the monitoring service is started by default and all drifts will be reported in the Event Viewer. In our case, we will go via the Azure portal, and force a configuration drift. In my case, I will go and disaable the policy (instead of having it in Report Only mode).</p> <p></p> <p>The monitoring service, by default, runs every 15 minutes. Because we do not want to wait for this to get automatically triggered, we will run the followin gPowerShell command to manually trigger it:</p> <pre><code>Test-DSCConfiguration -Detailed\n</code></pre> <p></p> <p>This will analyze the current state of our tenant against what has been defined in our desired configuration file in Step 8 above and will return the list of resources that are both in the desired state and not in the desired state. In our case, we only have 1 resource defined and we know it is not in the desired state because we just manually forced a drift. Note that to speed up the analysis process, you can omit the -Detailed switch which will cause the command to simply return true or false. To get additional details about the drift, we can open Event Viewer and look at Applications and Services Logs &gt; M365DSC. There should be an entry in there that provides granular details about what our drift is.</p> <p></p>"},{"location":"blog/posts/2024/getting-started-m365dsc/#step10","title":"Step 10 - Automatically Remediate to Configuration Drifts\u2693","text":"<p>The last topic we will cover as part of this blog post, is the auto-remediation feature of PowerShell Desired State Configuration. By default, our LCM service is set in ApplyAndMonitor mode.</p> <p></p> <p>This means that when drifts are detected, the service will only report them in the Event Viewer and won't attempt to automatically remediate to them. To change this setting and set the LCM into ApplyAndAutocorrect mode, we need to eat our own dog food and use DSC to appy the configuration. This can be achieved by creating, compiling and applying a special configuration file known as a Meta MOF. To do so, simply execute the following lines of code:</p> <pre><code>[DSCLocalConfigurationManager()]\nConfiguration M365AgentConfig\n{\n    Node Localhost\n    {\n        Settings\n        {\n            COnfigurationMode = 'ApplyAndAutocorrect'\n        }\n    }\n}\nM365AgentConfig | Out-Null\nSet-DSCLocalConfigurationManager M365AgentConfig -Force\n</code></pre> <p>To confirm that the change was successful, check the status of the LCM:</p> <pre><code>Get-DSCLocalConfigurationManager\n</code></pre> <p></p> <p>Once this is properly set, the LCM service will automatically fix any detected drift by re-applying the good known configuration for the instance the next time is executes, which in my case is every 15 minutes (ConfigurationModeFrequencyMins).</p>"},{"location":"blog/posts/2024/m365dsc-performance-considerations/","title":"Performance Considerations for Microsoft365DSC","text":"Performance Considerations for Microsoft365DSC 2024-11-29 <p>In this article we will cover various things you should consider when trying to improve the performance of Snapshots and Monitoring/Deployment when using Microsoft365DSC. This is a topic of concern for almost every customer I get to talk to, and there are various things that users can do to improve the overall performance of their solutions.</p>"},{"location":"blog/posts/2024/m365dsc-performance-considerations/#noteverything","title":"Only Export What You Need\u2693","text":"<p>By default, doing an export of a tenant's configuration using the Export-M365DSCConfiguration cmdlet will include over 405 resource types as part of the capture. Most customer I talk to don't need to capture it all. Our recommendation is to make sure you only capture the components you need and are interested in exporting. The Export-M365DSCConfiguration cmdlet offers various ways to specify subsets of the resources you want to export:</p> <ul> <li>Components: This parameter lets you specify the individual resource types you wish to export. For example, if you only care about Conditional Access Policies and Applications in Entra Id, you could specify the parameter as -Components @('AADConditionalAccessPolicy, 'AADApplication'). The Microsoft365DSC Export site allows you to visually select the components you want and build the associated command.</li> <li>Workloads: This parameter lets you specify the workloads you whish to export the resources for. For example, if you want to export all of the Exchange Online resources types, instead of specifying each one using the Components parameter, you can use the -Workloads @(\"EXO\") parameter instead.</li> <li>Mode: The cmdlet include the Mode parameter which let's you specify 3 modes (Default, Full, Lite). Each one includes different set of resources that will be included as part of the export.</li> </ul>"},{"location":"blog/posts/2024/m365dsc-performance-considerations/#exportfilters","title":"Use Filters\u2693","text":"<p>It is one thing to only select the resource types you wish to capture, but what about if you only want certain instances of these resource types to be captured as part of your export? By using the Filter parameter with the Export-M365DSCConfiguration cmdlet, you can scope any instance type down to the specific instances you want. For example, the newly introduced AADRoleManagementPolicyRule resource tends to take a very long time to export all of its associated instances. What if you are only interested in capturing a specific privileged role, say Global Administrator instead of all of them? The following lines of code will allow you to achieve exactly this:</p> <pre><code>$Filters = @{\n    AADRoleManagementPolicyRule = \"displayName eq 'Global Administrator' \"\n}\n\nExport-M365DSCConfiguration @Global:IntegrationParams `\n                            -Components 'AADRoleManagementPolicyRule' `\n                            -Filters $Filters\n</code></pre> <p></p>"},{"location":"blog/posts/2024/m365dsc-performance-considerations/#controlplane","title":"Try to Avoid Data Plane Resource Types\u2693","text":"<p>Whenever I do customer presentations, I always introduce this topic as the \"It's not because it's avaialble that you SHOULD use it\" section. Microsoft365DSC today supports over 440+ resource types, where some of them fall into what we consider being part of the control plane and some others fall into data plane. In our definition, control plane represents configuration settings that are normally only made available to the administrators via the various admin centers, whereas the data plane represent configuration settings that can also be managed by end-users. Consider the Planner resources for example, these clearly fall into the data plane. It wouldn't make sense for your organization to control these via DSC, even less to monitor them for configuration drifts. The whole point of having a Planner tasks is that it will begin in the Not Started phase with 0% completion and hopefully get to the Completed stage with 100% completion. You would never want to monitor this for drifts since end-users can interact with a task and modify it. Therefore you should always ask yourself whether or not you need to include these as part of your config and if it's worth including them in the export.</p> <p>There are some cases that fall more into a grey zone. Teams channels is a great example of this where they can both be controlled via the Teams admin center, but as an owner of the team I can also change its settings and remove/create and delete the channels. You need to be careful before capturing those as part of your configuration and be intentional about how you intend to use it. If you are simply to try to capture a backup of resource types for compliance or reporting pusposes, that's fine but just know it will take longer to export those as resource types from the data plane tend to have many instances. We would never recommend you use DSC to monitor resources that are part of the data plane.</p>"},{"location":"blog/posts/2024/m365dsc-performance-considerations/#skipdependencies","title":"Skip Dependencies Validation\u2693","text":"<p>We took a design decision a long time ago to validate that the machine from which customers are running DSC have the right versions of the required dependencies installed. Because we don't control the full logic flow when DSc is being run via the Local Configuration Manager (e.g., via Start-DSCConfiguration or Test-DSCConfiguration), we opted to add a check in every Get/Set/Test/Export function for every resource. While the first call will always be the heaviest, it still takes up some cycles to have to verify this for every resource. To help reduce the overhead of the dependency validation, we introduced a global variable that can be set to explicitely tell M365DSC not to validate the dependencies. While setting this value to skip the dependency check will improve the performance of the overall process, it is mostly going to help at the initiation phase, where it will reduce the initial overhead required to initiate the first resource export. If you are considering disabling this check, you should consider running the following line of code before executing the wanted operation:</p> <pre><code>$Global:M365DSCSkipDependenciesValidation = $true\n</code></pre> <p>When running preliminary benchmarks with a single resource type (AADApplication with 37 instances), we've observed a 13% of reduction in overall completion time. Please take this with a grain of salt since as mentioned above, it mostly helps speed up the script warmup process and doesn't have much impact on the subsequent resource export.</p>"},{"location":"blog/posts/2024/m365dsc-performance-considerations/#parallel","title":"Parallelize Jobs as Much as Possible\u2693","text":"<p>While this one might sound trivial, it is recommend to divider and conquer where possible. Microsoft365DSC is sequential in nature, therefore it is better to split the deployment, monitoring and snapshot jobs into several smaller parallel jobs. For example, instead of having a single process export all of the resource instance of your tenant, your should opt to split the process into smaller jobs such as having one process for each workload running in parallel. It is important to note that while this will help speed up the overall completion time, that you are still subject to the API throttling behind the scene; Microsoft365DSC doesn't escape from these restrictions.</p>"},{"location":"blog/posts/2024/m365dsc-performance-considerations/#telemetry","title":"Disable Telemetry\u2693","text":"<p>By default, Microsoft365DSC captures telemetry information to better understand how customers are using its various features and find areas of improvements for the overall solution. Customers can also choose to send this telemetry back to their own Application Insights environments for reporting purposes. For additional details on how to setup the telemetry for your agents, you can refer to the following article. This telemetry capture can, in some instances, add extra overhead on the solution and disabling it can help improve the overall speed of your operations.</p> <pre><code>Set-M365DSCTelemetryOption -Enabled $false\n</code></pre>"}]}